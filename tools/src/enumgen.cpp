/*
 * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

#include <tao/pegtl.hpp>
#include <tao/pegtl/contrib/abnf.hpp>

#include <fstream>
#include <iostream>
#include <sstream>
#include <map>
#include <regex>

namespace pegtl = tao::TAO_PEGTL_NAMESPACE;
using namespace pegtl;

struct ws : star<one<' ', '\t', '\n', '\r'>> {};
struct enumkeyword : seq<string<'e', 'n', 'u', 'm'>, opt<ws>, opt<string<'c', 'l', 'a', 's','s'>>> {};
struct scomment : seq<string<'/','/'>, star<not_one<'\n'>>, one<'\n'>>{};
struct mcomment : seq<string<'/','*'>, star<not_one<'/'>>, seq<opt<one<'*'>>,one<'/'>, one<'\n'>>>{};
struct comment : plus<sor<scomment, mcomment>>{};
struct intnum : seq<opt<one<'-'>>, plus<digit>> {};
struct name : plus<alnum> {};
struct enumpropertyname : name {};
struct enumname : name {};
struct enumkey : intnum {};

struct enumrefname : name {};
struct enumrefprop : name {};
struct enumref : seq<enumrefname, string<':', ':'>, enumrefprop> {};
struct enumvalue : seq<ws, enumpropertyname, ws, opt<seq<one<'='>, ws, sor<enumkey, enumref>>>, ws> {};
struct enumline : seq<ws, enumvalue, one<','>>{};
struct enuminner : star<seq<ws, sor<comment, enumline>>> {};
struct cppenum
    : seq<enumkeyword, ws, enumname, ws, one<'{'>, ws, enuminner, ws, one<'}'>, ws, one<';'>> {};
struct cpp : seq<star<sor<cppenum, any>>> {};

template <typename Rule>
struct enumaction : pegtl::nothing<Rule> {};

struct EnumItemRight {
    std::string comment;
    std::string name;
    int key;
};

struct EnumItem {
    std::string comment;
    std::string name;
    int key;
    std::string valueEnum;
    std::string valueEnumProp;
};

struct CppEnum {
    int index = 0;
    std::string name;
    std::vector<EnumItem*> values;
    std::map<std::string, EnumItem*> valuesMap;
};

struct State {
    std::string comment;
    std::string currentFileName;
    std::vector<CppEnum*> enums;
    std::map<std::string, CppEnum*> enumsMap;
};

template <>
struct enumaction<comment> {
    template< typename Input >
    static void apply(const Input& in, State& state) {
        state.comment = in.string();
    }
};

template <>
struct enumaction<enumpropertyname> {
    template< typename Input >
    static void apply(const Input& in, State& state) {
        auto* e = state.enums.back();
        EnumItem* value = new EnumItem();
        value->name = in.string();
        value->key = e->index++;
        value->comment = state.comment;
        state.comment = "";
        e->values.emplace_back(value);
        e->valuesMap[value->name] = value;
    }
};

template <>
struct enumaction<enumrefname> {
    template< typename Input >
    static void apply(const Input& in, State& state) {
        auto* e = state.enums.back();
        auto valueEnum = in.string();
        auto& last = e->values.back();
        last->valueEnum = valueEnum;
    }
};

template <>
struct enumaction<enumrefprop> {
    template< typename Input >
    static void apply(const Input& in, State& state) {
        auto* e = state.enums.back();
        auto valueEnumProp = in.string();
        auto& last = e->values.back();
        last->valueEnumProp = valueEnumProp;
    }
};

template <>
struct enumaction<enumkey> {
    template< typename Input >
    static void apply(const Input& in, State& state) {
        auto* e = state.enums.back();
        int key = std::stoi(in.string());
        auto* last = e->values.back();
        last->key = key++;
        e->index = last->key + 1;
    }
};

template <>
struct enumaction<enumname> {
    template< typename Input >
    static void apply(const Input& in, State& state) {
        CppEnum* e = new CppEnum();
        e->name = in.string();
        state.enums.emplace_back(e);
        state.enumsMap[e->name] = e;
    }
};

void
addAutoGenComments(std::ofstream& out, const CppEnum* e) {
    out << "/**\n"
        << " * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n"
        << " */\n\n"
        << "/**\n"
        <<  " * AUTOGENERATED FILE. DO NOT MODIFY!\n"
        << " * This file is autogenerated by enumgen.\n"
        << " */\n\n";
}

void
generateTypescript(const State& state, const std::string& writeDir,
                   const std::vector<std::string>& filter) {

    for (const CppEnum* cppenum : state.enums) {

        bool matched = filter.empty();
        for (const std::string& pattern : filter) {
            matched |= std::regex_match(cppenum->name, std::regex(pattern));
            if (matched)
                break;
        }
        if (!matched) {
            continue;
        }

        std::ofstream out;

        out.open(writeDir + "/" + cppenum->name + ".ts");
        addAutoGenComments(out, cppenum);

        out << "export enum " << cppenum->name << " {\n";
        for (const auto* val : cppenum->values) {
            if(!val->comment.empty()) {
                out << "    " << val->comment;
            }
            if(val->valueEnumProp.length() > 0 && val->valueEnum.length() > 0) {
                auto refEnumIt = state.enumsMap.find(val->valueEnum);
                if(refEnumIt != state.enumsMap.end()) {
                    auto refEnum = refEnumIt->second;
                    if(refEnum->valuesMap.find(val->valueEnumProp) != refEnum->valuesMap.end()) {
                        auto refItem = refEnum->valuesMap[val->valueEnumProp];
                        out << "    " << val->name << " = " << refItem->key << ",\n";
                    }
                }
            }
            else {
                out << "    " << val->name << " = " << val->key << ",\n";
            }
        }
        out << "}";
        out << "\n";
        out.close();
    }
}

void
generateJava(const State& state, const std::string& writeDir, const std::string& package,
             const std::vector<std::string>& filter) {
    for (const CppEnum* cppenum : state.enums) {

        bool matched = filter.empty();
        for (const std::string& pattern : filter) {
            matched |= std::regex_match(cppenum->name, std::regex(pattern));
            if (matched)
                break;
        }
        if (!matched) {
            continue;
        }

        std::ofstream out;
        out.open(writeDir + "/" + cppenum->name + ".java");
        addAutoGenComments(out, cppenum);
        out << "package " << package << ";\n\n";

        out << "import android.util.SparseArray;\n\n";
        out << "public enum " << cppenum->name << " {\n\n";
        for (int i = 0; i < cppenum->values.size(); i++) {
            const auto* val = cppenum->values[i];
            if(!val->comment.empty()) {
                out << "    " << val->comment;
            }
            out << "    " << val->name << "(" << val->key << ")";
            if (i != cppenum->values.size() - 1) {
                out << ",";
            }
            else {
                out << ";";
            }
            out << "\n";
        }

        out << "\n";
        out << "    private static SparseArray<" << cppenum->name << "> values = null;\n";
        out << "\n";
        out << "    public static " << cppenum->name << " valueOf(int idx) {\n";
        out << "        if(" << cppenum->name << ".values == null) {\n";
        out << "            " << cppenum->name << ".values = new SparseArray<>();\n";
        out << "            " << cppenum->name << "[] values = " << cppenum->name << ".values();\n";
        out << "            for(" << cppenum->name << " value : values) {\n";
        out << "                " << cppenum->name << ".values.put(value.getIndex(), value);\n";
        out << "            }\n";
        out << "        }\n";
        out << "        return " << cppenum->name << ".values.get(idx);\n";
        out << "    }\n";
        out << "\n";
        out << "    private final int index;\n";
        out << "\n";
        out << "    " << cppenum->name << " (int index) {\n";
        out << "        this.index = index;\n";
        out << "    }\n";
        out << "\n";
        out << "    public int getIndex() { return this.index; }\n";
        out << "}";
        out.close();
    }
}

static void usage(std::string msg="")
{
    if (!msg.empty())
        std::cout << msg << std::endl;

    std::cout <<
        R"(
Usage: enumgen [options] [--] FILE+

  Generate enums for a target language.  Files should be in C/C++

  Options:
     -o,--output PATH           Path to generated output directory. Defaults to current directory.
                                The directory must already exist (enumgen will not create a new directory)
     -f,--filter STRING         Regex filter.  Accepted multiple times.
     -p,--package PACKAGE       Java package.
     -l,--language LANGUAGE     Language to generate.  May be 'typescript' or 'java'.  Required.
     -v, --verbose              Verbose mode
     --version                  Displays version information and exist
     --, --ignore_rest          All arguments following this one are treated as files
     -h,--help                  Print this help
)";
    exit(msg.empty() ? 0 : 1);
}

int
main(int argc, char** argv) {
    std::string out(".");
    std::vector<std::string> filter;
    std::string package;
    std::string language;
    bool verbose = false;

    std::vector<std::string> args(argv + 1, argv + argc);
    for (auto iter = args.begin(); iter != args.end() && !iter->empty() && iter->front() == '-' ; ) {
        auto takeOne = [&](std::string name) {
            iter = args.erase(iter);
            if (iter == args.end()) {
                std::cerr << name << " expects a value" << std::endl;
                exit(1);
            }
            auto result = *iter;
            iter = args.erase(iter);
            return result;
        };

        if (*iter == "-h" || *iter == "--help") {
            usage();
        } else if (*iter == "--version") {
            std::cout << argv[0] << "  version: 1.0" << std::endl;
            return 0;
        } else if (*iter == "-o" || *iter == "--output") {
            out = takeOne("output");
        } else if (*iter == "-f" || *iter == "--filter") {
            filter.emplace_back(takeOne("filter"));
        } else if (*iter == "-p" || *iter == "--package") {
            package = takeOne("package");
        } else if (*iter == "-l" || *iter == "--language") {
            language = takeOne("language");
        } else if (*iter == "-v" || *iter == "--verbose") {
            iter = args.erase(iter);
            verbose = true;
        } else if (*iter == "--" || *iter == "--ignore_rest") {
            args.erase(iter);
            break;
        } else {
            std::cerr << "Unrecognized option " << *iter << std::endl;
            return 1;
        }
    }

    if (language != "typescript" && language != "java") {
        std::cerr << "Language must be 'typescript' or 'java'" << std::endl;
        return 1;
    }

    if (language == "java" && package.empty()) {
        std::cerr << "You must supply the java package with the -p option" << std::endl;
        return 1;
    }

    if (verbose) {
        std::cerr << "out='" << out << "'" << std::endl
                  << "package='" << package << "'" << std::endl
                  << "language='" << language << "'" << std::endl
                  << "filter=";
        for (const auto& m : filter)
            std::cerr << m << " ";
        std::cerr << std::endl << "files=";
        for (const auto& m : args)
            std::cerr << m << " ";
        std::cerr << std::endl;
    }

    // All of the remaining arguments in the "args" array are input files
    State state;
    for (const auto& filePath : args) {
        std::ifstream ifs(filePath);
        std::stringstream ss;
        ss << ifs.rdbuf();
        std::string contents = ss.str();
        state.currentFileName = filePath;
        pegtl::string_input<> in(contents, "");
        pegtl::parse<cpp, enumaction>(in, state);
    }

    if (language == "typescript") {
        generateTypescript(state, out, filter);
    }
    else if (language == "java") {
        generateJava(state, out, package, filter);
    }

    return 0;
}


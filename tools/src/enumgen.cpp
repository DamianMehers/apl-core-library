/*
 * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
#include "tclap/CmdLine.h"
#include <algorithm>
#include <iostream>
#include <string>

#include <pegtl.hh>
#include <pegtl/contrib/abnf.hh>

#include <fstream>
#include <map>
#include <regex>
#include <string>
#include <vector>

using namespace TCLAP;
using namespace pegtl;

struct ws : star<one<' ', '\t', '\n', '\r'>> {};
struct enumkeyword : seq<string<'e', 'n', 'u', 'm'>, opt<ws>, opt<string<'c', 'l', 'a', 's','s'>>> {};
struct scomment : seq<string<'/','/'>, star<not_one<'\n'>>, one<'\n'>>{};
struct mcomment : seq<string<'/','*'>, star<not_one<'/'>>, seq<opt<one<'*'>>,one<'/'>, one<'\n'>>>{};
struct comment : plus<sor<scomment, mcomment>>{};
struct intnum : seq<opt<one<'-'>>, plus<digit>> {};
struct name : plus<alnum> {};
struct enumpropertyname : name {};
struct enumname : name {};
struct enumkey : intnum {};

struct enumrefname : name {};
struct enumrefprop : name {};
struct enumref : seq<enumrefname, string<':', ':'>, enumrefprop> {};
struct enumvalue : seq<ws, enumpropertyname, ws, opt<seq<one<'='>, ws, sor<enumkey, enumref>>>, ws> {};
struct enumline : seq<ws, enumvalue, one<','>>{};
struct enuminner : star<seq<ws, sor<comment, enumline>>> {};
struct cppenum
    : seq<enumkeyword, ws, enumname, ws, one<'{'>, ws, enuminner, ws, one<'}'>, ws, one<';'>> {};
struct cpp : seq<star<sor<cppenum, any>>> {};

template <typename Rule>
struct enumaction : pegtl::nothing<Rule> {};

struct EnumItemRight {
    std::string comment;
    std::string name;
    int key;
};

struct EnumItem {
    std::string comment;
    std::string name;
    int key;
    std::string valueEnum;
    std::string valueEnumProp;
};

struct CppEnum {
    int index = 0;
    std::string name;
    std::string fileName;
    std::vector<EnumItem*> values;
    std::map<std::string, EnumItem*> valuesMap;
    size_t line;
};

struct State {
    std::string comment;
    std::string currentFileName;
    std::vector<CppEnum*> enums;
    std::map<std::string, CppEnum*> enumsMap;
};

template <>
struct enumaction<comment> {
    static void apply(const input& in, State& state) {
        state.comment = in.string();
    }
};

template <>
struct enumaction<enumpropertyname> {
    static void apply(const input& in, State& state) {
        auto* e = state.enums.back();
        EnumItem* value = new EnumItem();
        value->name = in.string();
        value->key = e->index++;
        value->comment = state.comment;
        state.comment = "";
        e->values.emplace_back(value);
        e->valuesMap[value->name] = value;
    }
};

template <>
struct enumaction<enumrefname> {
    static void apply(const input& in, State& state) {
        auto* e = state.enums.back();
        auto valueEnum = in.string();
        auto& last = e->values.back();
        last->valueEnum = valueEnum;
    }
};

template <>
struct enumaction<enumrefprop> {
    static void apply(const input& in, State& state) {
        auto* e = state.enums.back();
        auto valueEnumProp = in.string();
        auto& last = e->values.back();
        last->valueEnumProp = valueEnumProp;
    }
};

template <>
struct enumaction<enumkey> {
    static void apply(const input& in, State& state) {
        auto* e = state.enums.back();
        int key = std::stoi(in.string());
        auto* last = e->values.back();
        last->key = key++;
        e->index = last->key + 1;
    }
};

template <>
struct enumaction<enumname> {
    static void apply(const input& in, State& state) {
        CppEnum* e = new CppEnum();
        e->name = in.string();
        e->fileName = state.currentFileName;
        e->line = in.line();
        state.enums.emplace_back(e);
        state.enumsMap[e->name] = e;
    }
};

void
addAutoGenComments(std::ofstream& out, const CppEnum* e) {
    out << "/**\n"
        << " * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n"
        << " */\n\n"
        << "/**\n"
        <<  " * AUTOGENERATED FILE. DO NOT MODIFY!\n"
        << " * This file is autogenerated by enumgen from:\n"
        << " * " << e->fileName << " line " << e->line << "\n"
        << " */\n\n";
}

void
generateTypescript(const State& state, const std::string& writeDir,
                   const std::vector<std::string>& filter) {

    for (const CppEnum* cppenum : state.enums) {

        bool matched = filter.empty();
        for (const std::string& pattern : filter) {
            matched |= std::regex_match(cppenum->name, std::regex(pattern));
            if (matched)
                break;
        }
        if (!matched) {
            continue;
        }

        std::ofstream out;

        out.open(writeDir + "/" + cppenum->name + ".ts");
        addAutoGenComments(out, cppenum);

        out << "export enum " << cppenum->name << " {\n";
        for (const auto* val : cppenum->values) {
            if(!val->comment.empty()) {
                out << "    " << val->comment;
            }
            if(val->valueEnumProp.length() > 0 && val->valueEnum.length() > 0) {
                auto refEnumIt = state.enumsMap.find(val->valueEnum);
                if(refEnumIt != state.enumsMap.end()) {
                    auto refEnum = refEnumIt->second;
                    if(refEnum->valuesMap.find(val->valueEnumProp) != refEnum->valuesMap.end()) {
                        auto refItem = refEnum->valuesMap[val->valueEnumProp];
                        out << "    " << val->name << " = " << refItem->key << ",\n";
                    }
                }
            }
            else {
                out << "    " << val->name << " = " << val->key << ",\n";
            }
        }
        out << "}";
        out << "\n";
        out.close();
    }
}

void
generateJava(const State& state, const std::string& writeDir, const std::string& package,
             const std::vector<std::string>& filter) {
    for (const CppEnum* cppenum : state.enums) {

        bool matched = filter.empty();
        for (const std::string& pattern : filter) {
            matched |= std::regex_match(cppenum->name, std::regex(pattern));
            if (matched)
                break;
        }
        if (!matched) {
            continue;
        }

        std::ofstream out;
        out.open(writeDir + "/" + cppenum->name + ".java");
        addAutoGenComments(out, cppenum);
        out << "package " << package << ";\n\n";

        out << "import android.util.SparseArray;\n\n";
        out << "public enum " << cppenum->name << " {\n\n";
        for (int i = 0; i < cppenum->values.size(); i++) {
            const auto* val = cppenum->values[i];
            if(!val->comment.empty()) {
                out << "    " << val->comment;
            }
            out << "    " << val->name << "(" << val->key << ")";
            if (i != cppenum->values.size() - 1) {
                out << ",";
            }
            else {
                out << ";";
            }
            out << "\n";
        }

        out << "\n";
        out << "    private static SparseArray<" << cppenum->name << "> values = null;\n";
        out << "\n";
        out << "    public static " << cppenum->name << " valueOf(int idx) {\n";
        out << "        if(" << cppenum->name << ".values == null) {\n";
        out << "            " << cppenum->name << ".values = new SparseArray<>();\n";
        out << "            " << cppenum->name << "[] values = " << cppenum->name << ".values();\n";
        out << "            for(" << cppenum->name << " value : values) {\n";
        out << "                " << cppenum->name << ".values.put(value.getIndex(), value);\n";
        out << "            }\n";
        out << "        }\n";
        out << "        return " << cppenum->name << ".values.get(idx);\n";
        out << "    }\n";
        out << "\n";
        out << "    private final int index;\n";
        out << "\n";
        out << "    " << cppenum->name << " (int index) {\n";
        out << "        this.index = index;\n";
        out << "    }\n";
        out << "\n";
        out << "    public int getIndex() { return this.index; }\n";
        out << "}";
        out.close();
    }
}

int
main(int argc, char** argv) {
    try {

        CmdLine cmd("Generates enums for target language", ' ', "1.0");

        UnlabeledMultiArg<std::string> inputArg("input", "C/C++ file or files", true, "input",
                                                "string");
        cmd.add(inputArg);

        std::vector<std::string> allowedLanguages;
        allowedLanguages.emplace_back("typescript");
        allowedLanguages.emplace_back("java");
        ValuesConstraint<std::string> vallowedLanguages(allowedLanguages);
        ValueArg<std::string> languageArg("l", "language", "Language to generate", true,
                                          "typescript", &vallowedLanguages);
        cmd.add(languageArg);

        ValueArg<std::string> packageArg("p", "package", "Java package", false, "", "string");
        cmd.add(packageArg);

        MultiArg<std::string> enumFilterArg("f", "filter", "Regex Filter", false, "string");
        cmd.add(enumFilterArg);

        ValueArg<std::string> outArg("o", "output", "Path to generated output directory", false,
                                     ".", "string");
        cmd.add(outArg);

        cmd.parse(argc, argv);

        auto files = inputArg.getValue();
        std::string language = languageArg.getValue();
        std::string out = outArg.getValue();
        auto filter = enumFilterArg.getValue();

        State state;

        for (const auto& filePath : files) {
            std::ifstream ifs(filePath);
            std::stringstream ss;
            ss << ifs.rdbuf();
            std::string contents = ss.str();
            pegtl::data_parser parser(contents.c_str(), "Test");
            state.currentFileName = filePath;
            parser.parse<cpp, enumaction>(state);
        }
        if (language == "typescript") {
            generateTypescript(state, out, filter);
        }
        else if (language == "java") {
            std::string package = packageArg.getValue();
            if (package.empty()) {
                std::cerr << "You must supply the java package with the -p option" << std::endl;
                return 1;
            }
            generateJava(state, out, package, filter);
        }
        return 0;
    }
    catch (ArgException& e) {
        std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl;
        return 1;
    }
}
